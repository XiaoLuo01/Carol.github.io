<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="努力中的前端开发工程师"><title>10分钟解读 Javascript 的Async/Await | 静默如初</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">10分钟解读 Javascript 的Async/Await</h1><a id="logo" href="/.">静默如初</a><p class="description">The Greatness is Achieved through Diligence and Retarded by Laziness.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/category/"><i class="fa fa-th"> 分类</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">10分钟解读 Javascript 的Async/Await</h1><div class="post-meta">May 6, 2018<span> | </span><span class="category"><a class="categroyTitle" href="/categories/Web前端/">Web前端</a><i class="fa fa-angle-double-right"></i><a class="categroyTitle" href="/categories/Web前端/Javascript/">Javascript</a><i class="fa fa-angle-double-right"></i><a class="categroyTitle" href="/categories/Web前端/Javascript/英文文档翻译/">英文文档翻译</a><i class="fa fa-angle-double-right"></i></span></div><div class="clear"><div class="toc-article" id="toc"><i class="fa fa-angle-double-left"></i><div class="toc-content"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-Async-Await"><span class="toc-number">1.</span> <span class="toc-text">什么是 Async/Await?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Async-声明了一个异步函数-async-function-someName"><span class="toc-number">1.1.</span> <span class="toc-text">Async - 声明了一个异步函数(async function someName(){...})</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Awaut-暂停异步函数的执行-var-result-await-someAsyncCall"><span class="toc-number">1.2.</span> <span class="toc-text">Awaut - 暂停异步函数的执行(var result = await someAsyncCall();)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-Await会创建之前那样的promise吗"><span class="toc-number">2.</span> <span class="toc-text">Async/Await会创建之前那样的promise吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Async-Await处理错误"><span class="toc-number">3.</span> <span class="toc-text">Async/Await处理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器支持"><span class="toc-number">4.</span> <span class="toc-text">浏览器支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div class="post-content"><p>原文链接<a href="https://tutorialzine.com/2017/07/javascript-async-await-explained" target="_blank" rel="noopener">https://tutorialzine.com/2017/07/javascript-async-await-explained</a></p>
<blockquote>
<p>长期以来，javascript开发者们都必须依赖回调函数来处理异步请求代码。结果就是当我们遇到类似下面的方法时，很多人都会经历的回调地狱。（下面是一段代码，这里省略，可以直接看链接）</p>
</blockquote>
<blockquote>
<p>幸运的是， 随着ES6的发布，我们有了Promise里面的then（或者称为.then()）来处理异步回调，他们提供了很多处理回调的可供选择的方法，而且很多社区快速的运用了他们来替代原来的代码。</p>
</blockquote>
<blockquote>
<p>现在随着最近Async/Await的加入， Javascript将会越来越容易开发。</p>
</blockquote>
<h3 id="什么是-Async-Await"><a href="#什么是-Async-Await" class="headerlink" title="什么是 Async/Await?"></a>什么是 Async/Await?</h3><blockquote>
<p>Async/Await是我们长久一来一直期盼的javascript的一个特性， 它可以让我们在异步函数处理上更加便捷方便而且也易于理解，它是建立在Promise的基础上，而且也是可以兼容所有Promise的常用API。</p>
</blockquote>
<blockquote>
<p>Async/Await这个名字是来自<strong>async</strong>和<strong>await-</strong>这两个关键字, 可以帮助我们理清异步代码:</p>
</blockquote>
<h4 id="Async-声明了一个异步函数-async-function-someName"><a href="#Async-声明了一个异步函数-async-function-someName" class="headerlink" title="Async - 声明了一个异步函数(async function someName(){...})"></a>Async - 声明了一个异步函数(<code>async function someName(){...}</code>)</h4><ul>
<li>在Promise里面自动的转换为一个个常规的函数</li>
<li>在函数内部return的时候就可以调用异步函数解决</li>
<li>这是异步函数就可以使用await了</li>
</ul>
<h4 id="Awaut-暂停异步函数的执行-var-result-await-someAsyncCall"><a href="#Awaut-暂停异步函数的执行-var-result-await-someAsyncCall" class="headerlink" title="Awaut - 暂停异步函数的执行(var result = await someAsyncCall();)"></a>Awaut - 暂停异步函数的执行(<code>var result = await someAsyncCall();</code>)</h4><ul>
<li>运用在Promise回调之前，await会强制代码停止运行直到Promise请求完成并返回结果才会继续代码执行</li>
<li>Await只能与Promise一同使用，在回调函数里面是不起作用的</li>
<li>Await可以单独用在异步函数里面</li>
</ul>
<p>下面有一个简单的例子可以帮助我们理解:</p>
<p>&emsp;例如我们想从服务器获取一个JSON文件, 我们可以写一个函数使用<strong>axios</strong>(这里用axios来发送请求)数据库来发送一个HTTP的get请求地址<strong><a href="https://tutorialzine.com/misc/files/example.json" target="_blank" rel="noopener">https://tutorialzine.com/misc/files/example.json</a></strong>。发送请求之后必须等待服务器响应，这样的请求就是一个HTTP的异步请求。</p>
<p>&emsp;下面我们用两种方法来实现，第一种用Promise， 第二钟使用Async/Await</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSOn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        axios.get(<span class="string">'https://tutorialzine.com/misc/files/example.json'</span>)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//使用resolve返回结果</span></span><br><span class="line">                resolve(json);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async/Await 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//async关键字会自动创建一个Promise对象并返回</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSONAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//await关键字帮我们处理了并不需要then方法</span></span><br><span class="line">    <span class="keyword">let</span> json = <span class="keyword">await</span> axios.get(<span class="string">'https://tutorialzine.com/misc/files/example.json'</span>);</span><br><span class="line">    <span class="comment">//直接返回类似于同步函数</span></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;很明显我们可以看到使用Async/Await版本的代码更简洁也更容易阅读，除了语法不同，其实两个函数是一样的，他们都返回了一个Promise对象和接收了从axios响应过来的JSON数据， 所以异步函数还可以写成这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getJSONAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//DO something with result</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Async-Await会创建之前那样的promise吗"><a href="#Async-Await会创建之前那样的promise吗" class="headerlink" title="Async/Await会创建之前那样的promise吗?"></a>Async/Await会创建之前那样的promise吗?</h3><p> &emsp;并不全是，当你使用Async/Await时在底层来说还是会使用到Promise，所以如果你对Promise有了一定的理解之后会有很大的帮助，也是我们所推荐的。</p>
<p> &emsp;甚至在一些案例当中，如果使用Async/Await不能满足我们要求时，还是会回过头来请求Promise的帮助。其中的一个使用场景就是当我们需要同时等待很多独立的异步回调完成执行。</p>
<p> &emsp;下面的例子就是这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">await</span> getValueA(); <span class="comment">// getValueA 2秒完成</span></span><br><span class="line">  <span class="keyword">let</span> B = <span class="keyword">await</span> getValueB(); <span class="comment">// getValueB 4秒完成</span></span><br><span class="line">  <span class="keyword">let</span> C = <span class="keyword">await</span> getValueC(); <span class="comment">// getValueC 3秒完成</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> A*B*C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;每一个await的回调都会等待前一个回调返回结果才会执行，所以如果我们一次性请求的话，这整个函数从开始到结束总共需要花费9秒钟（2+4+3)。</p>
<p>&emsp;当这三个顺序可变的并不彼此依赖的函数，这并不是最好的解决方法。换句话说，我们不需要知道A是否需要在B的前面获取，而是可以同时获取到三个的值，而尽量用最少的时间等待。</p>
<p>&emsp;所以我们就可以使用Promise.all()在同一个时间发生的所有的请求，并且可以确保在往下执行代码之前可以获取到所有的返回值，因为它会让所有的回调函数可以并行发送请求，而不是一个接一个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同时请求所有的函数</span></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([ getValueA, getValueB, getValueC ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> results.reduce(<span class="function">(<span class="params">total,value</span>) =&gt;</span> total * value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;这种方法就可以花更少的时间，getValueA 和 getValueC这两个函数在 getValueB完成的时候早就结束了，所以整个函数运行的时间就是最慢的那个请求的时间，有效了减小了总时间。</p>
<h3 id="Async-Await处理错误"><a href="#Async-Await处理错误" class="headerlink" title="Async/Await处理错误"></a>Async/Await处理错误</h3><p>&emsp;使用Async/Await的另一个好处就是允许我们在try/catch里面获取到任务不可预期的报错，只需要将await回调包起来即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomethingAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个请求有可能会失败</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> someAsyncCall();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 这里就是获取到的报错信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;catch语句会处理从等待异步回调或者任何其他我们写在try语句里面有可能会失败的代码所引发的报错。</p>
<p>&emsp;如果情景需要的话，我们也可以从async函数里面抓取到报错，因为所有的async函数都返回一个Promise对象，这样我们就可以很简单的使用.catch()事件来处理我们的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用try catch语句</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomethingAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步函数有可能会失败</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> someAsyncCall();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数的时候来处理报错</span></span><br><span class="line">doSomethingAsync().</span><br><span class="line">    .then(successHandler)</span><br><span class="line">    .catch(errorHandler);</span><br></pre></td></tr></table></figure>
<p>&emsp;你更喜欢并且坚持使用哪个方法来处理报错是很重要的，同时使用try/catch语句和.catch()会尽可能的定位到问题所在。</p>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>&emsp;Async/Await在大部分主流浏览器上都是支持的，但是IE所有的版本（包括IE11）都不兼容在没有使用外部的库之类的话。</p>
<p>&emsp;Node开发者们也可以在Node8及以上的版本上体验到async的好处，近两年将会应用于LTS版本。</p>
<p>&emsp;如果这篇文章并不能让你理解，这里还有几篇JS的文章like<a href="https://babeljs.io/docs/plugins/transform-async-to-generator/" title="Babel" target="_blank" rel="noopener">Babel</a> 和 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html" title="TypeScipt" target="_blank" rel="noopener">TypeScript</a>，而且在node.js里面还提供了他们自己的跨平台版本供我们学习 <a href="https://github.com/yortus/asyncawait" title="asyncawait" target="_blank" rel="noopener">asyncawait</a>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>随着Async/Await的出现，javascript语言在代码的可读性以及使用简单的方面上提升了一个很大的跨度，它可以让异步代码的编程变得像常规的同步函数一样方便, 这对于不管是新手还是js的老司机来说都是一件值得感激的事情。</p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.1" async></script><a class="article-share-link" data-url="http://www.luo01.cn/2018/05/06/10分钟解读 Javascript 的Async-Await/" data-id="cjm3k8my30000wsuybtwpvfnj" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsUlEQVR42u3aQW4bMQwF0Nz/0inQVYCmnv8psU6B51XgeCQ9LYYEyY+P+PP5+/P17z+/yX/f7pKvMPzg4eHhjY7+ernX2yTfJ9fxGpDgv1kBDw8Pb43XBoONoJJfa3JmPDw8vJ/Aa1PqNkU+2REPDw/vf+HlR0yebS8LDw8P7728pBiRb/k6MJxf5UqtBQ8PDy/mzQoK7/17vb+Hh4eHN+qq32pf5au16fjDafHw8PAWeCdNppMi7OzdPvwlHh4e3lXeya3kL+5Zrps89fokeHh4eBu8k9Gou+nybGCruFY8PDy8S7y8idW2u2ZpcZuyP7TT8PDw8NZ4RWJaprnJAEF+oe3wFh4eHt4GLxmiardM1txLrB+KEXh4eHiXeHnTK3+VJyEhwVwbvcLDw8O7xBuOMZXPtqHi1mp4eHh427w8kZ01xvJXf14oqavUeHh4eMe8JI1ukbOW/0kxIgoPeHh4eAu8tnDQXkrbZqsT6L+dHA8PD+8qb9buarfJy7vtjg8pOx4eHt4ab1ZoyNtj5y20dqwBDw8Pb4933nk/KVLMRq9moQUPDw/vFu+kDHEeHlrA0dAVHh4e3iVeGxLyA83a/PmoQTvwioeHh7fBqzPueOn8CtqTFOMIeHh4eP+E1w5LteGkDTN5wo2Hh4e3x0sKr+dtqvzVn4eBCI+Hh4e3zMsb83mhoS3d5mtGxQs8PDy8BV5eTk3+24aKdt88YODh4eHt8WaJcjscMEugTwYL8PDw8PZ4s7ZWklgnwSMvWMzOgIeHh7fHy1PhvCzb3mX70i9aa3h4eHhrvDYY3IpFeQiZBS08PDy89/KiVlP57EmAiX6Jh4eH98N4eWF3VgtJrubhnHh4eHhrvLYYkVzNLDk+udZvvsHDw8Nb4LUNsKSwmweY2SUedfPw8PDw5rxfojLaT3Awi98AAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/Async-Await-Js/">Async/Await Js</a></div><div class="post-nav"><a class="pre" href="/2018/06/20/Javascript 设计模式(二)/">Javascript 设计模式(二) --- 构造器模式与模块模式</a><a class="next" href="/2018/05/05/Javascript 设计模式-一/">Javascript 设计模式(一) --- 概念小谈</a></div></div><script type="text/javascript" src="/js/artical.js?v=0.0.1"></script></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><a href="http://luo01.cn/"><img class="protrait" src="http://luo01.cn/img/protrait.png" alt=""/></a></div><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web前端/">Web前端</a><span class="category-list-count">14</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web前端/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web前端/Javascript/">Javascript</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web前端/Vue/">Vue</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web前端/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web前端/小程序/">小程序</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web前端/构建工具/">构建工具</a><span class="category-list-count">2</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Async-Await-Js/" style="font-size: 15px;">Async/Await Js</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/设计模式-Js/" style="font-size: 15px;">设计模式 Js</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/web-小程序/" style="font-size: 15px;">web 小程序</a> <a href="/tags/web-自动化-构建工具/" style="font-size: 15px;">web 自动化 构建工具</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/15/gulp常用插件/">gulp常用插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/gulp详细入门教程/">gulp详细入门教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/08/小程序如何引入fontAwesome/">小程序如何引入fontAwesome</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/08/小程序实现左滑删除功能/">小程序实现左滑删除功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/08/小程序封装滚动Tab选项卡-可滑动/">小程序封装滚动Tab选项卡: 可滑动</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/08/小程序出现【需要身份验证】弹窗解决办法/">小程序出现【需要身份验证】弹窗解决办法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/24/Github如何进行PR(Pull Request)的操作/">Github如何进行PR(Pull Request)操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/小程序简易开发/">微信小程序简易开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/20/Javascript 设计模式(二)/">Javascript 设计模式(二) --- 构造器模式与模块模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/10分钟解读 Javascript 的Async-Await/">10分钟解读 Javascript 的Async/Await</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul class="post-list"> <li class="post-list-item"> <a class="post-list-link" href="http://www.ruanyifeng.com" title="阮一峰" target="_blank">阮一峰</a></li><li class="post-list-item"> <a class="post-list-link" href="http://www.zhangxinxu.com/wordpress/" title="张鑫旭" target="_blank">张鑫旭</a></li><li class="post-list-item"> <a class="post-list-link" href="https://coolshell.cn/featured" title="左耳朵耗子" target="_blank">左耳朵耗子</a></li><li class="post-list-item"> <a class="post-list-link" href="http://www.giscafer.com/" title="Nickbing Lao" target="_blank">Nickbing Lao</a></li><li class="post-list-item"> <a class="post-list-link" href="https://ioliu.cn/" title="云淡风轻" target="_blank">云淡风轻</a></li><li class="post-list-item"> <a class="post-list-link" href="https://www.haomwei.com/" title="紫禁屠夫" target="_blank">紫禁屠夫</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">静默如初.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.1"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>