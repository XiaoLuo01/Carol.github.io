<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>搭建属于自己的博客</title>
      <link href="/2018/07/06/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/06/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;自从学习前端一来, 一直想自己搭建一个独立的博客, 也纠结过是否直接使用第三方博客平台, 但是每次看到网页上面的广告就无法忍受, 所以想来想去还是决定用自己搭建的, 刚好自己是学前端的, 好像没有搭建过博客就说不过去，虽然网上面的教程有很多, 但是还是想自己记录一下学习过程, 下面就开始吧。</p></blockquote><h3 id="开发环境（windows）"><a href="#开发环境（windows）" class="headerlink" title="开发环境（windows）"></a>开发环境（windows）</h3><h4 id="安装-Node-js-和-Git"><a href="#安装-Node-js-和-Git" class="headerlink" title="安装 Node.js 和 Git"></a>安装 Node.js 和 Git</h4><p> 直接到官网下载安装即可 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">NodeJS</a><br> Git 也可以直接在官网去下载</p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p> 安装完node.js和git之后，即可以通过npm安装hexo了, 打开git bash,键入以下命令<br>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure></p><p>  安装完成后可以通过 <code>hexo -v</code> 查看 hexo 版本信息</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>  安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件<br>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init <span class="symbol">&lt;folder&gt;</span></span><br><span class="line"><span class="keyword">cd</span> <span class="symbol">&lt;folder&gt;</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>  初始化完成后，你会在该文件夹下得到如下的目录结构:<br>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── <span class="keyword">package</span>.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="keyword">public</span></span><br><span class="line">├── <span class="keyword">source</span></span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><h3 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h3><p>执行命令 <code>hexo s</code><br>成功启动则会看到反馈信息<br>[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>. Press Ctrl+C to stop.<br>此时端口4000被打开，打开浏览器，输入上面所示网址<br>出现了默认的主题界面，心情是不是有点小激动呢~<br><img src="/2018/07/06/搭建hexo博客/hexo-web.png" alt=""><br>到此为止hexo的初始化已经完成，接下来就是相关配置。</p><h3 id="博客配置"><a href="#博客配置" class="headerlink" title="博客配置"></a>博客配置</h3><p>博客的基本配置都在 <code>_config.yml</code> 文件中打开该文件我们可以看到，在其中我们可以对网站显示的相关个人信息进行修改以及主题的使用的等。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">静默如初</span>  <span class="comment">#博客名</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">The</span> <span class="string">Greatness</span> <span class="string">is</span> <span class="string">Achieved</span> <span class="string">through</span> <span class="string">Diligence</span> <span class="string">and</span> <span class="string">Retarded</span> <span class="string">by</span> <span class="string">Laziness.</span> <span class="comment">#副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">努力中的前端开发工程师</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="comment">#关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Carol</span> <span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span><span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span>  <span class="comment">#时区，此处不填写，hexo会以你目前电脑的时区为默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://www.luo01.cn</span>  <span class="comment">#域名</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory  暂不配置，使用默认值</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing 文章布局等，使用默认值</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span> <span class="comment">#高亮</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数学公式</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format 时间格式</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span>  <span class="comment">#每页显示的文章数，0表示不分页</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions 插件配置</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">maupassant</span>  <span class="comment">#使用的主题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment  用于部署到github</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:XiaoLuo01/XiaoLuo01.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><p>执行命令 <code>hexo n “我的第一篇博文”</code><br>系统会自动在<code>_post </code>目录下生成文件 “我的第一篇博文.md”<br>之后用编辑器编辑md文件就好啦！（要用markdown语法编辑哦~）<br>markdown的语法可以参考 <a href="http://ibruce.info/2013/11/26/markdown/" target="_blank" rel="noopener">http://ibruce.info/2013/11/26/markdown/</a> 以及一些搜索到的教程。</p><h3 id="hexo的其他指令"><a href="#hexo的其他指令" class="headerlink" title="hexo的其他指令"></a>hexo的其他指令</h3><p>下面只写一些常用命令及部分简写<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new 新建文件</span><br><span class="line">hexo g == hexo generate 生成静态文件</span><br><span class="line">hexo s == hexo<span class="built_in"> server </span>启动服务器</span><br><span class="line">heox d == hexo deploy 部署网站</span><br><span class="line">hexo list 列出网站资料</span><br></pre></td></tr></table></figure></p><p>同时，hexo还支持复合命令，如 <code>hexo d -g </code>意为 先静态化处理，再部署<br>详细指令说明可参阅 <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands.html</a></p><h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><h4 id="静态化处理"><a href="#静态化处理" class="headerlink" title="静态化处理"></a>静态化处理</h4><p>执行命令 <code>hexo g</code><br>在此说明一下静态化处理的目的，由于我们用hexo所搭建的这个博客，是静态网站，即只有html,css和javascript，无法动态更新。静态化处理即生成只有html、css和javascript的网站。</p><h4 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h4><ul><li>注册github帐号</li><li>建立一个仓库，名为<code>[your_user_name.github.io]</code>  <strong>这里必须要注意的是: 一定要以自己的github名命名</strong></li><li>添加SSH公钥到 <font color="red">[Account settings -&gt; SSH Keys -&gt; Add SSH Key]</font></li><li>有了github帐号之后， 编辑配置文件_config.yml，在deploy部分，设置github的项目地址</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line"><span class="attribute">type</span>: git</span><br><span class="line"><span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:example/example.github.io.git</span><br></pre></td></tr></table></figure><ul><li>添加SSH<br>首先设置用户名和密码:</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"example@163.com"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"example"</span></span><br></pre></td></tr></table></figure><p>然后生成密钥:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">example</span>@<span class="keyword">163</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure></p><p>上述命令如果成功，会在根目录下的.ssh文件夹内生成<code>id_rsa</code>和 <code>id_rsa.pub</code>两个文件<br>打开id_rsa.pub文件，复制里面的内容添加到 Add SSH Key</p><p><img src="/2018/07/06/搭建hexo博客/pic02.png" alt=""></p><p>然后执行命令 <code>hexo d</code><br>若没问题的话会提示你输入帐号密码，之后就部署成功了，可以在github查看，点击仓库上侧的setting, 这页面中可以看到</p><p><img src="/2018/07/06/搭建hexo博客/pic03.png" alt=""><br><strong>这里还需要注意的是: source需要设置为master分支</strong></p><blockquote><p>在执行hexo deploy命令时，可能会提示找不到git, 解决方法：<br>在Hexo 3.0版本后deploy git 被分开的，所以需要安装，安装命令如下: <code>npm install hexo-deployer-git –save</code> ,安装好后再尝试一下就ok</p></blockquote><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>如果对于github默认分配的二级域名example.github.io满意的话，就用这个也是可以的。如果不太满意，可以购买一个域名，博主是从阿里云购买的.cn 域名。</p><p>设置域名有两种方式: </p><ul><li>主域名绑定: 如example.com</li><li>子域名绑定：如blog.example.com</li></ul><h4 id="主域名绑定"><a href="#主域名绑定" class="headerlink" title="主域名绑定"></a>主域名绑定</h4><ul><li>在source根目录下新建文件 <font color="skyblue"> CNAME </font>，无后缀，纯文本文件，内容为要绑定的域名<br>example.com,如果要使用 <a href="http://www.example.com的形式，文件内容改为www.example.com" target="_blank" rel="noopener">www.example.com的形式，文件内容改为www.example.com</a></li><li>DNS设置<ul><li>主机记录@，类型A，记录值192.30.252.153</li><li>主机记录www，类型A，记录值192.30.252.153</li><li>参考 <a href="https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider" target="_blank" rel="noopener">https://help.github.com/articles/tips-for-configuring-an-a-record-with-your-dns-provider</a></li></ul></li></ul><h4 id="子域名绑定"><a href="#子域名绑定" class="headerlink" title="子域名绑定"></a>子域名绑定</h4><ul><li>比如使用域名example.com的子域名blog.example.com <font color="skyblue"> CNAME </font>文件内容为blog.example.com</li><li>DNS设置<ul><li>主机记录blog，类型CNAME，记录值example.github.io</li><li>参考<a href="https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider" target="_blank" rel="noopener">https://help.github.com/articles/tips-for-configuring-a-cname-record-with-your-dns-provider</a></li></ul></li></ul><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a><br>可以从这上面挑选一个自己喜欢的主题, 比如我觉得next还不错，<br>进入github的项目地址后, 复制项目地址, 在themes目录下，执行命令<code>git clone <a href="https://github.com/iissnan/hexo-theme-next.git" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next.git</a><br></code></p><p>完成后会在theme目录下生成hexo-theme-next主题文件夹<br>打开 _config.yml 配置文件，找到 theme 选项<br>将默认的 theme: landscape 更换为 theme: hexo-theme-next<br>此时，启动服务器 hexo s 可查看效果，之后便可静态化然后部署到github上即可。</p><p><a href="http://theme-next.iissnan.com/这是next主题的说明，可参照此修改默认配置。" target="_blank" rel="noopener">http://theme-next.iissnan.com/这是next主题的说明，可参照此修改默认配置。</a><br>其他主题也可借鉴说明</p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>至于插件有很多，可以按照自己的喜好配置插件，下面只给出几个教程的连接，需要的同学自行配置就好。<br><a href="http://www.tuicool.com/articles/AfQnQjy" target="_blank" rel="noopener">http://www.tuicool.com/articles/AfQnQjy</a><br>还有一些插件是主题自带的，注意就好。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>到此, 博客就已经搭建完毕啦~<br>虽然搭建博客的过程中遇到很多问题，但是博客成功搭建之后，心里真是觉得很满足。<br>希望想搭建博客的同学能在这篇文章中得到帮助。</p>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vuejs最佳实践方法</title>
      <link href="/2018/07/06/Vuejs%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/07/06/Vuejs%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p><img src="/2018/07/06/Vuejs最佳实践/vue.png" alt=""></p><blockquote><p>&emsp;&emsp;对大部分人来说，掌握Vue.js基本的几个API后就已经能够正常地开发前端网站。但如果你想更加高效地使用Vue来开发，下面几个方法能更好的适用于vue场景。</p></blockquote><h3 id="第一招-化繁为简的watchers"><a href="#第一招-化繁为简的watchers" class="headerlink" title="第一招: 化繁为简的watchers"></a>第一招: 化繁为简的watchers</h3><p><strong><em>场景还原:</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">  <span class="keyword">this</span>.fetchPostList()</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    searchInputValue()&#123;</span><br><span class="line">       <span class="keyword">this</span>.fetchPostList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件创建的时候我们获取一次列表，同时监听input框，每当发生变化的时候重新获取一次筛选后的列表这个场景很常见，有没有办法优化一下呢？</li></ul><p><strong><em>招式解析：</em></strong></p><ul><li>首先，在<code>watchers</code>中，可以直接使用函数的字面量名称；其次，声明<code>immediate:true</code>表示创建组件时立马执行一次。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  searchInputValue:&#123;</span><br><span class="line">    handler: <span class="string">'fetchPostList'</span>,</span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二招：一劳永逸的组件注册"><a href="#第二招：一劳永逸的组件注册" class="headerlink" title="第二招：一劳永逸的组件注册"></a>第二招：一劳永逸的组件注册</h3><p><strong><em>场景还原:</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BaseButton <span class="keyword">from</span> <span class="string">'./baseButton'</span></span><br><span class="line"><span class="keyword">import</span> BaseIcon <span class="keyword">from</span> <span class="string">'./baseIcon'</span></span><br><span class="line"><span class="keyword">import</span> BaseInput <span class="keyword">from</span> <span class="string">'./baseInput'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    BaseButton,</span><br><span class="line">    BaseIcon,</span><br><span class="line">    BaseInput</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;BaseInput v-model=<span class="string">"searchText"</span> @keydown.enter=<span class="string">"search"</span>/&gt;</span><br><span class="line">&lt;BaseButton @click=<span class="string">"search"</span>&gt;</span><br><span class="line">  &lt;BaseIcon name=<span class="string">"search"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/BaseButton&gt;</span></span><br></pre></td></tr></table></figure><ul><li>我们写了一堆基础UI组件，然后每次我们需要使用这些组件的时候，都得先import，然后声明components，很繁琐！秉持能偷懒就偷懒的原则，我们要想办法优化！</li></ul><p><strong><em>招式解析：</em></strong></p><ul><li><p>我们需要借助一下神器webpack，使用 <strong>require.context()</strong> 方法来创建自己的（模块）上下文，从而实现自动动态require组件。这个方法需要3个参数：<font color="#0000dd">要搜索的文件夹目录，是否还应该搜索它的子目录，以及一个匹配文件的正则表达式</font>。</p></li><li><p>我们在components文件夹添加一个叫global.js的文件，在这个文件里借助webpack动态将需要的基础组件统统打包进来。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capitalizeFirstLetter</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> string.charAt(<span class="number">0</span>).toUpperCase() + string.slice(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(<span class="string">'.'</span>, <span class="literal">false</span>, /\.vue$/) <span class="comment">//找到components文件夹下以.vue命名的文件</span></span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line">  <span class="keyword">const</span> componentName = capitalizeFirstLetter(fileName.replace(<span class="regexp">/^\.\//</span>, <span class="string">''</span>).replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>))</span><br><span class="line"><span class="comment">//因为得到的filename格式是:'./baseButton.vue',所以这里我们去掉头和尾，只保留真正的文件名</span></span><br><span class="line"></span><br><span class="line">  Vue.component(componentName, componentConfig.default || componentConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>最后我们在main.js中import ‘components/global.js’，然后我们就可以随时随地使用这些基础组件，无需手动引入了</li></ul><h3 id="第三招：釜底抽薪的router-key"><a href="#第三招：釜底抽薪的router-key" class="headerlink" title="第三招：釜底抽薪的router key"></a>第三招：釜底抽薪的router key</h3><p><strong><em>场景还原:</em></strong></p><ul><li>下面这个场景真的是伤透了很多程序员的心…先默认大家用的是Vue-router来实现路由的控制。假设我们在写一个博客网站，需求是从/post-page/a，跳转到/post-page/b。然后我们惊人的发现，页面跳转后数据竟然没更新？！原因是vue-router”智能地”发现这是同一个组件，然后它就决定要复用这个组件，所以你在created函数里写的方法压根就没执行。通常的解决方案是监听$route的变化来初始化数据，如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    loading: <span class="literal">false</span>,</span><br><span class="line">    error: <span class="literal">null</span>,</span><br><span class="line">    post: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line"> <span class="string">'$route'</span>: &#123;</span><br><span class="line">    handler: <span class="string">'resetData'</span>,</span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  resetData() &#123;</span><br><span class="line">   <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.error = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.post = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.getPost(<span class="keyword">this</span>.$route.params.id)</span><br><span class="line">  &#125;,</span><br><span class="line">  getPost(id)&#123;</span><br><span class="line">      <span class="comment">// 操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>招式解析：</em></strong></p><ul><li>给router-view添加一个unique的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件。（虽然损失了一丢丢性能，但避免了无限的bug）。同时，注意我将key直接设置为路由的完整路径，一举两得。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=<span class="string">"$route.fullpath"</span>&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    loading: false,</span><br><span class="line">    error: null,</span><br><span class="line">    post: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">  this.getPost(this.$route.params.id)</span><br><span class="line">&#125;,</span><br><span class="line">methods () &#123;</span><br><span class="line">  getPost(postId) &#123;    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四招-无所不能的render函数"><a href="#第四招-无所不能的render函数" class="headerlink" title="第四招: 无所不能的render函数"></a>第四招: 无所不能的render函数</h3><p><strong><em>场景还原:</em></strong></p><ul><li>vue要求每一个组件都只能有一个根元素，当你有多个根元素时，vue就会给你报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"route in routes"</span> :key=<span class="string">"route.name"</span>&gt;</span><br><span class="line">    &lt;router-link :to=<span class="string">"route"</span>&gt;</span><br><span class="line">      &#123;&#123; route.title &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ERROR - Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.</span></span><br></pre></td></tr></table></figure><p><strong><em>招式解析：</em></strong></p><ul><li>那有没有办法化解呢，答案是有的，只不过这时候我们需要使用render()函数来创建HTML，而不是template。其实用js来生成html的好处就是极度的灵活功能强大，而且你不需要去学习使用vue的那些功能有限的指令API，比如v-for, v-if。（reactjs就完全丢弃了template)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">functional: <span class="literal">true</span>,</span><br><span class="line">render(h, &#123; props &#125;) &#123;</span><br><span class="line"> <span class="keyword">return</span> props.routes.map(<span class="function"><span class="params">route</span> =&gt;</span></span><br><span class="line">  &lt;li key=&#123;route.name&#125;&gt;</span><br><span class="line">     &lt;router-link to=&#123;route&#125;&gt;</span><br><span class="line">        &#123;route.title&#125;</span><br><span class="line">     &lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/</span>li&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五招：无招胜有招的高阶组件"><a href="#第五招：无招胜有招的高阶组件" class="headerlink" title="第五招：无招胜有招的高阶组件"></a>第五招：无招胜有招的高阶组件</h3><p><strong>划重点：这一招威力无穷，请务必掌握</strong></p><ul><li>当我们写组件的时候，通常我们都需要从父组件传递一系列的props到子组件，同时父组件监听子组件emit过来的一系列事件。举例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;BaseInput :value=<span class="string">"value"</span> label=<span class="string">"密码"</span> placeholder=<span class="string">"请填写密码"</span> @input=<span class="string">"handleInput"</span> @focus=<span class="string">"handleFocus&gt;&lt;/BaseInput&gt;</span></span><br><span class="line"><span class="string">//子组件</span></span><br><span class="line"><span class="string">&lt;template&gt;</span></span><br><span class="line"><span class="string">  &lt;label&gt;</span></span><br><span class="line"><span class="string">    &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;input :value="</span>value<span class="string">" :placeholder="</span>placeholder<span class="string">" @focus=$emit('focus', $event)"</span> @input=<span class="string">"$emit('input', $event.target.value)"</span> &gt;</span><br><span class="line">  &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure><p><strong>有下面几个优化点：</strong></p><ul><li>1、每一个从父组件传到子组件的props,我们都得在子组件的Props中显式的声明才能使用。这样一来，我们的子组件每次都需要申明一大堆props, 而类似placeholer这种dom原生的property我们其实完全可以直接从父传到子，无需声明。方法如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=<span class="string">"value"</span>  v-bind=<span class="string">"$attrs"</span> @input=<span class="string">"$emit('input', $event.target.value)"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定，并且可以通过 v-bind="$attrs" 传入内部组件——在创建更高层次的组件时非常有用。</span></span><br></pre></td></tr></table></figure><ul><li>2、注意到子组件的@focus= $emit(‘focus’, $event) 其实什么都没做，只是把event传回给父组件而已，那其实和上面类似，我完全没必要显式地申明：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=<span class="string">"value"</span> v-bind=<span class="string">"$attrs"</span>  v-on=<span class="string">"listeners"</span>&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  listeners() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">       ...this.$listeners,</span><br><span class="line">       input: <span class="function"><span class="params">event</span> =&gt;</span> <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,event.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件——在创建更高层次的组件时非常有用。</span></span><br></pre></td></tr></table></figure><ul><li>3、需要注意的是，由于我们input并不是BaseInput这个组件的根节点，而默认情况下父作用域的不被认作 props 的特性绑定将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。所以我们需要设置 <font color="#dd00dd"><strong>inheritAttrs:false</strong></font>，这些默认行为将会被去掉, 以上两点的优化才能成功。</li></ul>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git入门与进阶</title>
      <link href="/2018/07/06/Git%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>/2018/07/06/Git%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/log.png" alt=""></p><blockquote><p>&emsp;&emsp;Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目，是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p></blockquote><h3 id="Git-与-SVN-对比"><a href="#Git-与-SVN-对比" class="headerlink" title="Git 与 SVN 对比"></a>Git 与 SVN 对比</h3><ul><li>SVN 是集中式版本控制软件，版本库是放在中央服务器，当我们进行项目开发时，首先要从中央服务器获取最新版本；开发完毕后要将代码提交到中央服务器。<font color="red">集中版本式控制系统必须联网才能工作，即使是局域网也必须保持与局域网服务器的连接。</font></li><li>Git 是分布式版本控制软件，它没有中央服务器一说，每个人的电脑就是一个完整的版本库。当我们需要共享文件的时候只需要创建一个共享版本库进行push或pull就能看到对方修改。</li></ul><h3 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h3><p>&emsp;&emsp;一般工作流程如下（具体命令步骤将在下文提出）：</p><ul><li>从远程仓库克隆代码到本地作为本地库（可直接克隆至编辑器工作空间）</li><li>代码开发完毕后提交至本地仓库</li><li>从远程仓库拉取最新版代码，有冲突解决冲突（有冲突时本地仓库文件夹会有“!”标记，有可能标记会有延迟）。</li><li>处理好本地库代码后提交到远程库共享代码</li></ul><h3 id="Git-的下载与安装"><a href="#Git-的下载与安装" class="headerlink" title="Git 的下载与安装"></a>Git 的下载与安装</h3><p>&emsp;&emsp;由于本人使用的是 windows 系统，所以只阐述 windows 下 git 的安装及使用。</p><ul><li><p>Git 软件下载</p><p>  官方下载地址：<strong><a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></strong></p></li><li><p>Git 软件安装</p><p>  下载完成之后双击进行安装，选择自己的安装路径，傻瓜式 next 一路到底。</p></li></ul><h3 id="Git-本地仓库"><a href="#Git-本地仓库" class="headerlink" title="Git 本地仓库"></a>Git 本地仓库</h3><blockquote><p>&emsp;&emsp;版本库又名仓库，repository，可以理解成一个目录，这个目录里面所有文件都将被 Git 管理起来，每个文件的修改、删除、新增，Git 都能跟踪，并且在无需联网的情况下具有完整的版本管理能力。</p></blockquote><ul><li>创建本地版本库</li></ul><p>在磁盘里任选并进入一个文件夹，右击空白处，如下：</p><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic1.png" alt=""></p><p>点击 <code><strong>Git Bash Here</strong></code>，在出现的窗口中输入 <code><strong>git init</strong></code>，并且将会出现隐藏文件夹 <code><strong>.git</strong></code>。演示里面的文件夹 Git Test 就是我们所说的工作区，隐藏文件夹 <code><strong>.git</strong></code> 就是版本库。</p><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic2.png" alt=""></p><h3 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h3><blockquote><p>&emsp;&emsp;目前我们已经有了本地 Git 仓库，如果需要协作开发，则必须有一个远程仓库。常用的远程仓库是 github：<strong><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></strong>。</p></blockquote><ul><li>创建 Github 账号（各自摸索…）</li><li>创建远程仓库：</li></ul><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic3.png" alt=""></p><p>填写好仓库名称，仓库描述，选择 <code>Public</code>( <code>Private 是付费的</code>)，就可以 <code>Create repository</code> 了。</p><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic4.png" alt=""></p><ul><li>SSH 密匙</li></ul><blockquote><p>&emsp;&emsp;SSH 是英文 Secure Shell的简写形式。通过使用 SSH，它可以把所有传输的数据进行加密，这样可以防止 DNS 欺骗和 IP 欺骗。目前 Github 采用这种方式对传输数据进行加密。</p></blockquote><p>在 windows 系统下，我们使用 <code><strong>Git Bash.exe</strong></code> 来生成密匙，命令： <code><strong>ssh-keygen -t rsa</strong></code>。具体操作如下图：</p><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic5.png" alt=""></p><p>执行完命令后，会在 windows <font color="red">本地用户下的 <strong>.ssh</strong> 目录下生成公钥和私钥</font>。</p><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic6.png" alt=""></p><p>密钥生成后，需要在 Github 上配置密匙本地才能访问，操作如下：</p><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic7.png" alt=""></p><p>点击 <strong>Settings</strong>，选中右边侧边栏的 <strong>SSH and GPS keys</strong>，再点击右上角出现 <strong>New SSH key</strong>，将本地的<font color="red"><strong>公钥</strong></font>里面的信息全部复制，按下图操作：</p><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic8.png" alt=""></p><p>点击 <strong>And SSH key</strong> 按钮完成配置！</p><h3 id="连接-Git-远程仓库并同步"><a href="#连接-Git-远程仓库并同步" class="headerlink" title="连接 Git 远程仓库并同步"></a>连接 Git 远程仓库并同步</h3><ol><li>初始化账号：我们是第一次连接远程仓库，本地 Git 并不知道我们的身份，因此我们需初始化自己的身份；<ul><li>git config user.name “你的Github账号名称(非邮箱)”</li><li>git config user.email “你的Github邮箱”</li></ul></li></ol><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic9.png" alt=""></p><ol start="2"><li>添加远程仓库<ul><li>git remote add 远端名称 远程库 SSH 地址</li></ul></li></ol><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic10.png" alt=""></p><ol start="3"><li>提交到 Github 远程仓库（个人在项目开发中使用的操作）<ul><li>git status（查看当前状态，包括当前分支、增删改过的文件）</li><li>git add . （将当前目录下的所有操作过的文件添加）</li><li>git commit -m’提交说明’ （提交到本地仓库）</li><li>git pull （拉取远程库的文件，每次提交到本地库后需进行此操作，有冲突则要修改并merge）</li><li>git push （将拉取和自己操作过的文件提交至远程仓库）</li></ul></li></ol><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic11.png" alt=""></p><ol start="4"><li>完成所有操作后我们可以在自己的 Github 上查看自己所提交的内容</li></ol><p><img src="https://github.com/shitouxiaocheng01/JavaNotes/raw/master/Img/Git/pic12.png" alt=""></p><p> <strong>以上是本人的浅显理解，如有错误，请指正，感激不尽！</strong></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信小程序简易开发</title>
      <link href="/2018/07/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E6%98%93%E5%BC%80%E5%8F%91/"/>
      <url>/2018/07/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E6%98%93%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<blockquote><p>最近公司项目不是很赶, 所以平时还是有很多自由时间的, 刚好组长叫我做一个小程序的技术预研, 其实我以下所写的这些在微信官方文档上都有详细说明的, 我这里只是做一个简化以及对我自己的学习过程的一个记录。</p></blockquote><h3 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h3><blockquote><p>在开始小程序开发之前需要去官网注册一个appleID, 然后还需要下载小程序开发工具, 这些都比较简单, 这里就不累述了.  </p></blockquote><p>小程序注册链接: <a href="https://developers.weixin.qq.com/miniprogram/dev/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/</a></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>官方的开发工具准备了一个<code>QuickStart</code>项目。在创建时，如果选择空文件夹，开发者工具会提示：是否需要创建一个<code>QuickStart</code>项目。选择是，开发者工具会自动帮助我们在开发目录里生成一个简单的项目。</p><p><img src="/2018/07/06/微信小程序简易开发/sm_pic1.png" alt=""></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">└─ Demo/ ······················· 项目所在目录</span><br><span class="line">   ├─ pages/ ··························· 页面目录</span><br><span class="line">   │  ├─ index/ ························  index页面</span><br><span class="line">   │  │  ├─ index<span class="selector-class">.js</span> ···················   index页面逻辑</span><br><span class="line">   │  │  ├─ index<span class="selector-class">.wxml</span> ·················   index页面结构</span><br><span class="line">   │  │  └─ index<span class="selector-class">.wxss</span> ·················   index页面样式</span><br><span class="line">   │  └─ logs/ ·························  logs页面</span><br><span class="line">   │     ├─ logs<span class="selector-class">.js</span> ····················   logs页面逻辑</span><br><span class="line">   │     ├─ logs<span class="selector-class">.wxml</span> ··················   logs页面结构</span><br><span class="line">   │     └─ logs<span class="selector-class">.wxss</span> ··················   logs页面样式</span><br><span class="line">   ├─ utils/ ···························  公共脚本目录</span><br><span class="line">   │  └─ util<span class="selector-class">.js</span> ·······················   工具脚本</span><br><span class="line">   ├─ app<span class="selector-class">.js</span> ··························· 应用程序逻辑</span><br><span class="line">   ├─ app<span class="selector-class">.json</span> ························· 应用程序配置</span><br><span class="line">   └─ app<span class="selector-class">.wxss</span> ························· 应用程序公共样式</span><br></pre></td></tr></table></figure><h3 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h3><p>每个页面组件也分为四个文件组成:</p><ul><li><strong>[page-name].js</strong> <ul><li>页面逻辑文件，用于创建页面对象，以及处理页面生命周期控制和数据处理</li></ul></li><li><strong>[page-name].json</strong> : <ul><li>设置当前页面工作时的window的配置，此处会覆盖app.json中的window设置，也就是说只可以设置window中设置的属性 </li></ul></li><li><strong>[page-name].wxml</strong> :  <ul><li>wxml指的是Wei Xin Markup Language </li><li>用于定义页面中元素结构的，语法遵循XML语法，注意是XML语法，不是HTML语法 </li></ul></li><li><strong>[page-name].wxss</strong><ul><li>wxml指的是Wei Xin Style Sheet </li><li>用于定义页面样式的，语法遵循CSS语法，扩展了CSS基本用法和长度单位（主要就是rpx响应式像素） </li></ul></li></ul><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p><img src="/2018/07/06/微信小程序简易开发/config.jpg" alt="config"></p><p>小程序的配置文件分为两种: </p><ul><li>全局配置文件, 根目录下的 <code>app.json</code></li><li>页面配置文件, 每个页面目录下的<code>[page-name].json</code></li></ul><p><em><strong>app.json</strong></em>  —&gt;  项目配置声明文件 (指定项目的一些信息，比如导航栏样式颜色等等 )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当前程序是由哪些页面组成的（第一项默认为初始页面）所有使用到的组件或页面都必须在此体现</span></span><br><span class="line">  <span class="string">"pages"</span>: [ ... ],</span><br><span class="line">  <span class="comment">// 应用程序窗口设置</span></span><br><span class="line">  <span class="string">"window"</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// 应用导航栏设置</span></span><br><span class="line">  <span class="string">"tabBar"</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="comment">// 网络超时设置</span></span><br><span class="line">  <span class="string">"networkTimeout"</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 是否在控制台输出调试信息</span></span><br><span class="line">  <span class="string">"debug"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>[page-name].json</strong></em>  —&gt;  用于指定特定页面工作时，window的设置： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 导航条背景色</span></span><br><span class="line">  <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#35495e"</span>,</span><br><span class="line">  <span class="comment">// 导航条前景色（只能是white/black）</span></span><br><span class="line">  <span class="string">"navigationBarTextStyle"</span>: <span class="string">"white"</span>,</span><br><span class="line">  <span class="comment">// 导航条文本</span></span><br><span class="line">  <span class="string">"navigationBarTitleText"</span>: <span class="string">"电影 « 豆瓣"</span>,</span><br><span class="line">  <span class="comment">// 窗口背景颜色</span></span><br><span class="line">  <span class="string">"backgroundColor"</span>: <span class="string">"#fff"</span>,</span><br><span class="line">  <span class="comment">// 窗口前景色</span></span><br><span class="line">  <span class="string">"backgroundTextStyle"</span>: <span class="string">"dark"</span>,</span><br><span class="line">  <span class="comment">// 是否开启下拉刷新</span></span><br><span class="line">  <span class="string">"enablePullDownRefresh"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑层分析"><a href="#逻辑层分析" class="headerlink" title="逻辑层分析"></a>逻辑层分析</h3><h4 id="应用程序逻辑-app-js"><a href="#应用程序逻辑-app-js" class="headerlink" title="应用程序逻辑 app.js"></a>应用程序逻辑 <code>app.js</code></h4><p><code>app.js</code>作为项目主入口文件，用于创建应用程序对象 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App函数是一个全局函数，用于创建应用程序对象</span></span><br><span class="line">App(&#123;</span><br><span class="line">  <span class="comment">// ========== 全局数据对象（可以整个应用程序共享） ==========</span></span><br><span class="line">  globalData: &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ========== 应用程序全局方法 ==========</span></span><br><span class="line">  method1 (p1, p2) &#123; ... &#125;,</span><br><span class="line">  method2 (p1, p2) &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ========== 生命周期方法 ==========</span></span><br><span class="line">  <span class="comment">// 应用程序启动时触发一次</span></span><br><span class="line">  onLaunch () &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当应用程序进入前台显示状态时触发</span></span><br><span class="line">  onShow () &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当应用程序进入后台状态时触发</span></span><br><span class="line">  onHide () &#123; ... &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也就是说，当应用程序启动时会自动执行项目目录下的<code>app.js</code>文件。</p><p>在<code>app.js</code>中通过调用全局<code>App([option])</code>方法创建一个应用程序实例。</p><p>其中通过参数指定的一些特定的方法，会在特定的执行时机去执行，也就是说通常所说的生命周期事件方法。 </p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td style="text-align:center">onLaunch</td><td style="text-align:center">Function</td><td>生命周期函数–监听小程序初始化</td><td>当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</td></tr><tr><td style="text-align:center">onShow</td><td style="text-align:center">Function</td><td>生命周期函数–监听小程序显示</td><td>当小程序启动，或从后台进入前台显示，会触发 onShow</td></tr><tr><td style="text-align:center">onHide</td><td style="text-align:center">Function</td><td>生命周期函数–监听小程序隐藏</td><td>当小程序从前台进入后台，会触发 onHide</td></tr></tbody></table><p>也可以定义任意其他的对象成员（例如：方法和属性），这些成员可以在内部直接使用，或者外部通过获取<code>app</code>对象调用： </p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>其他</td><td>Any</td><td>开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问，一般用于存放业务逻辑配置，比如：API地址</td></tr></tbody></table><p>app.js </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  data1: <span class="string">'123'</span>,</span><br><span class="line">  data2: &#123; <span class="attr">message</span>: <span class="string">'hello world'</span> &#125;,</span><br><span class="line">  api: &#123;</span><br><span class="line">    list: <span class="string">'https://github.com/zce/'</span>,</span><br><span class="line">    detail: <span class="string">'https://github.com/zce/'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  foo () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>other.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getApp 也是全局函数，可以在任意地方调用，用于获取全局应用程序实例对象</span></span><br><span class="line"><span class="keyword">var</span> app = getApp();</span><br><span class="line"><span class="built_in">console</span>.log(app.data1);</span><br><span class="line"><span class="built_in">console</span>.log(app.data2);</span><br><span class="line"><span class="built_in">console</span>.log(app.foo());</span><br></pre></td></tr></table></figure><h4 id="页面逻辑-page-name-js"><a href="#页面逻辑-page-name-js" class="headerlink" title="页面逻辑[page-name].js"></a>页面逻辑<code>[page-name].js</code></h4><p><code>[page-name].js</code>是一个页面的重要组成部分，用于创建页面对象 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取全局应用程序对象</span></span><br><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Page也是一个全局函数，用来创建页面对象</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">// ========== 页面数据对象（可以暴露到视图中，完成数据绑定） ==========</span></span><br><span class="line">  data: &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ========== 页面方法（可以用于抽象一些公共的行为，例如加载数据，也可以用于定义事件处理函数） ==========</span></span><br><span class="line">  method1 (p1, p2) &#123; ... &#125;,</span><br><span class="line">  method2 (p1, p2) &#123; ... &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ========== 生命周期方法 ==========</span></span><br><span class="line">  <span class="comment">// 页面加载触发</span></span><br><span class="line">  onLoad () &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在应用程序执行到当前页面时，会执行当前页面下对应的<code>[page-name].js</code>文件。 在<code>[page-name].js</code>中通过调用全局<code>Page([option])</code>方法创建一个页面实例。</p><h5 id="Page-option-方法-option-参数说明"><a href="#Page-option-方法-option-参数说明" class="headerlink" title="Page([option])方法[option]参数说明"></a><code>Page([option])</code>方法<code>[option]</code>参数说明</h5><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>Object</td><td>页面的初始数据</td></tr><tr><td>onLoad</td><td>Function</td><td>生命周期函数–监听页面加载</td></tr><tr><td>onReady</td><td>Function</td><td>生命周期函数–监听页面初次渲染完成</td></tr><tr><td>onShow</td><td>Function</td><td>生命周期函数–监听页面显示</td></tr><tr><td>onHide</td><td>Function</td><td>生命周期函数–监听页面隐藏</td></tr><tr><td>onUnload</td><td>Function</td><td>生命周期函数–监听页面卸载</td></tr><tr><td>onPullDownRefreash</td><td>Function</td><td>页面相关事件处理函数–监听用户下拉动作</td></tr><tr><td>其他</td><td>Any</td><td>开发者可以添加任意的函数或数据到 object 参数中，用 this 可以访问</td></tr></tbody></table><h3 id="视图层分析"><a href="#视图层分析" class="headerlink" title="视图层分析"></a>视图层分析</h3><h4 id="page-name-wxml页面结构"><a href="#page-name-wxml页面结构" class="headerlink" title="[page-name].wxml页面结构"></a><code>[page-name].wxml</code>页面结构</h4><p><code>WXML（WeiXin Markup Language）</code>是<code>MINA框架</code>设计的一套标签语言，基于<code>XML</code>。</p><p>结合一些基础组件、事件系统、模板数据绑定，可以构建出页面的结构。</p><p>简单来说：wxml ≈ xml + 事件系统 + 模板引擎</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'JavaScript'</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'JavaScript+'</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'JavaScript++'</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  completed (e) &#123; ... &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123; todos &#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123; !item.completed &#125;&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">"completed"</span> <span class="attr">data-item-index</span>=<span class="string">"&#123;&#123; index &#125;&#125;"</span>&gt;</span> √ <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="page-name-wxss页面样式"><a href="#page-name-wxss页面样式" class="headerlink" title="[page-name].wxss页面样式"></a><code>[page-name].wxss</code>页面样式</h4><p><code>WXSS（WeiXin Style Sheets）</code>是<code>MINA框架</code>设计的一套标签语言，基于<code>XML</code>。</p><p><code>WXSS</code>用来决定了在<code>WXML</code>中定义的组件应该怎么显示。</p><p>为了适应广大的前端开发者，我们的<code>WXSS</code>具有<code>CSS</code>大部分特性。 同时为了更适合开发微信小程序，我们对<code>CSS</code>进行了扩充以及修改。扩展的特性有: </p><h5 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h5><p>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p><p>rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。</p><table><thead><tr><th>设备</th><th>rpx换算px (屏幕宽度/750)</th><th>px换算rpx (750/屏幕宽度)</th><th>rem换算rpx (750/20)</th></tr></thead><tbody><tr><td>iPhone5</td><td>1rpx = 0.42px</td><td>1px = 2.34rpx</td><td>1rem = 37.5rpx</td></tr><tr><td>iPhone6</td><td>1rpx = 0.5px</td><td>1px = 2rpx</td><td>1rem = 37.5rpx</td></tr><tr><td>iPhone6s</td><td>1rpx = 0.552px</td><td>1px = 1.81rpx</td><td>1rem = 37.5rpx</td></tr></tbody></table><blockquote><ul><li><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。</li><li><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</li></ul></blockquote><h5 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h5><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"common.wxss"</span>;</span><br><span class="line"><span class="selector-tag">text</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h5><p>目前只支持如下选择器</p><table><thead><tr><th>选择器</th><th>样例</th><th>样例描述</th></tr></thead><tbody><tr><td>.class</td><td>.intro</td><td>选择所有拥有 class=”intro” 的组件</td></tr><tr><td>#id</td><td>#firstname</td><td>选择拥有 id=”firstname” 的组件</td></tr><tr><td>element</td><td>view</td><td>选择所有 view 组件</td></tr><tr><td>element, element</td><td>view</td><td>checkbox 选择所有文档的 view 组件和所有的 checkbox 组件</td></tr><tr><td>::after</td><td>view::after</td><td>在 view 组件后边插入内容</td></tr><tr><td>::before</td><td>view::before</td><td>在 view 组件前边插入内容</td></tr></tbody></table><h5 id="全局样式与局部样式"><a href="#全局样式与局部样式" class="headerlink" title="全局样式与局部样式"></a>全局样式与局部样式</h5><p>定义在<code>app.wxss</code>中的样式为全局样式，作用于每一个页面。在<code>[page-name].wxss</code>文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖<code>app.wxss</code>中相同的选择器。</p>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Javascript 设计模式(二) --- 构造器模式与模块模式</title>
      <link href="/2018/06/20/Javascript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)/"/>
      <url>/2018/06/20/Javascript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;继续上一篇设计模式的学习笔记记录</p></blockquote><!-- ### Observer (观察者) 模式  -- 有待深究 --><!-- ### Mediator (中介者) 模式 --><h3 id="Prototype-原型-模式"><a href="#Prototype-原型-模式" class="headerlink" title="Prototype (原型) 模式"></a>Prototype (原型) 模式</h3>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> Javascript </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 Js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>10分钟解读 Javascript 的Async/Await</title>
      <link href="/2018/05/06/10%E5%88%86%E9%92%9F%E8%A7%A3%E8%AF%BB%20Javascript%20%E7%9A%84Async-Await/"/>
      <url>/2018/05/06/10%E5%88%86%E9%92%9F%E8%A7%A3%E8%AF%BB%20Javascript%20%E7%9A%84Async-Await/</url>
      <content type="html"><![CDATA[<p>原文链接<a href="https://tutorialzine.com/2017/07/javascript-async-await-explained" target="_blank" rel="noopener">https://tutorialzine.com/2017/07/javascript-async-await-explained</a></p><blockquote><p>长期以来，javascript开发者们都必须依赖回调函数来处理异步请求代码。结果就是当我们遇到类似下面的方法时，很多人都会经历的回调地狱。（下面是一段代码，这里省略，可以直接看链接）</p></blockquote><blockquote><p>幸运的是， 随着ES6的发布，我们有了Promise里面的then（或者称为.then()）来处理异步回调，他们提供了很多处理回调的可供选择的方法，而且很多社区快速的运用了他们来替代原来的代码。</p></blockquote><blockquote><p>现在随着最近Async/Await的加入， Javascript将会越来越容易开发。</p></blockquote><h3 id="什么是-Async-Await"><a href="#什么是-Async-Await" class="headerlink" title="什么是 Async/Await?"></a>什么是 Async/Await?</h3><blockquote><p>Async/Await是我们长久一来一直期盼的javascript的一个特性， 它可以让我们在异步函数处理上更加便捷方便而且也易于理解，它是建立在Promise的基础上，而且也是可以兼容所有Promise的常用API。</p></blockquote><blockquote><p>Async/Await这个名字是来自<strong>async</strong>和<strong>await-</strong>这两个关键字, 可以帮助我们理清异步代码:</p></blockquote><h4 id="Async-声明了一个异步函数-async-function-someName"><a href="#Async-声明了一个异步函数-async-function-someName" class="headerlink" title="Async - 声明了一个异步函数(async function someName(){...})"></a>Async - 声明了一个异步函数(<code>async function someName(){...}</code>)</h4><ul><li>在Promise里面自动的转换为一个个常规的函数</li><li>在函数内部return的时候就可以调用异步函数解决</li><li>这是异步函数就可以使用await了</li></ul><h4 id="Awaut-暂停异步函数的执行-var-result-await-someAsyncCall"><a href="#Awaut-暂停异步函数的执行-var-result-await-someAsyncCall" class="headerlink" title="Awaut - 暂停异步函数的执行(var result = await someAsyncCall();)"></a>Awaut - 暂停异步函数的执行(<code>var result = await someAsyncCall();</code>)</h4><ul><li>运用在Promise回调之前，await会强制代码停止运行直到Promise请求完成并返回结果才会继续代码执行</li><li>Await只能与Promise一同使用，在回调函数里面是不起作用的</li><li>Await可以单独用在异步函数里面</li></ul><p>下面有一个简单的例子可以帮助我们理解:</p><p>&emsp;例如我们想从服务器获取一个JSON文件, 我们可以写一个函数使用<strong>axios</strong>(这里用axios来发送请求)数据库来发送一个HTTP的get请求地址<strong><a href="https://tutorialzine.com/misc/files/example.json" target="_blank" rel="noopener">https://tutorialzine.com/misc/files/example.json</a></strong>。发送请求之后必须等待服务器响应，这样的请求就是一个HTTP的异步请求。</p><p>&emsp;下面我们用两种方法来实现，第一种用Promise， 第二钟使用Async/Await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSOn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        axios.get(<span class="string">'https://tutorialzine.com/misc/files/example.json'</span>)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//使用resolve返回结果</span></span><br><span class="line">                resolve(json);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async/Await 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//async关键字会自动创建一个Promise对象并返回</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSONAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//await关键字帮我们处理了并不需要then方法</span></span><br><span class="line">    <span class="keyword">let</span> json = <span class="keyword">await</span> axios.get(<span class="string">'https://tutorialzine.com/misc/files/example.json'</span>);</span><br><span class="line">    <span class="comment">//直接返回类似于同步函数</span></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;很明显我们可以看到使用Async/Await版本的代码更简洁也更容易阅读，除了语法不同，其实两个函数是一样的，他们都返回了一个Promise对象和接收了从axios响应过来的JSON数据， 所以异步函数还可以写成这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getJSONAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//DO something with result</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Async-Await会创建之前那样的promise吗"><a href="#Async-Await会创建之前那样的promise吗" class="headerlink" title="Async/Await会创建之前那样的promise吗?"></a>Async/Await会创建之前那样的promise吗?</h3><p> &emsp;并不全是，当你使用Async/Await时在底层来说还是会使用到Promise，所以如果你对Promise有了一定的理解之后会有很大的帮助，也是我们所推荐的。</p><p> &emsp;甚至在一些案例当中，如果使用Async/Await不能满足我们要求时，还是会回过头来请求Promise的帮助。其中的一个使用场景就是当我们需要同时等待很多独立的异步回调完成执行。</p><p> &emsp;下面的例子就是这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">await</span> getValueA(); <span class="comment">// getValueA 2秒完成</span></span><br><span class="line">  <span class="keyword">let</span> B = <span class="keyword">await</span> getValueB(); <span class="comment">// getValueB 4秒完成</span></span><br><span class="line">  <span class="keyword">let</span> C = <span class="keyword">await</span> getValueC(); <span class="comment">// getValueC 3秒完成</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> A*B*C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;每一个await的回调都会等待前一个回调返回结果才会执行，所以如果我们一次性请求的话，这整个函数从开始到结束总共需要花费9秒钟（2+4+3)。</p><p>&emsp;当这三个顺序可变的并不彼此依赖的函数，这并不是最好的解决方法。换句话说，我们不需要知道A是否需要在B的前面获取，而是可以同时获取到三个的值，而尽量用最少的时间等待。</p><p>&emsp;所以我们就可以使用Promise.all()在同一个时间发生的所有的请求，并且可以确保在往下执行代码之前可以获取到所有的返回值，因为它会让所有的回调函数可以并行发送请求，而不是一个接一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同时请求所有的函数</span></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([ getValueA, getValueB, getValueC ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> results.reduce(<span class="function">(<span class="params">total,value</span>) =&gt;</span> total * value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;这种方法就可以花更少的时间，getValueA 和 getValueC这两个函数在 getValueB完成的时候早就结束了，所以整个函数运行的时间就是最慢的那个请求的时间，有效了减小了总时间。</p><h3 id="Async-Await处理错误"><a href="#Async-Await处理错误" class="headerlink" title="Async/Await处理错误"></a>Async/Await处理错误</h3><p>&emsp;使用Async/Await的另一个好处就是允许我们在try/catch里面获取到任务不可预期的报错，只需要将await回调包起来即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomethingAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个请求有可能会失败</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> someAsyncCall();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="comment">// 这里就是获取到的报错信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;catch语句会处理从等待异步回调或者任何其他我们写在try语句里面有可能会失败的代码所引发的报错。</p><p>&emsp;如果情景需要的话，我们也可以从async函数里面抓取到报错，因为所有的async函数都返回一个Promise对象，这样我们就可以很简单的使用.catch()事件来处理我们的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用try catch语句</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomethingAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步函数有可能会失败</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> someAsyncCall();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数的时候来处理报错</span></span><br><span class="line">doSomethingAsync().</span><br><span class="line">    .then(successHandler)</span><br><span class="line">    .catch(errorHandler);</span><br></pre></td></tr></table></figure><p>&emsp;你更喜欢并且坚持使用哪个方法来处理报错是很重要的，同时使用try/catch语句和.catch()会尽可能的定位到问题所在。</p><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>&emsp;Async/Await在大部分主流浏览器上都是支持的，但是IE所有的版本（包括IE11）都不兼容在没有使用外部的库之类的话。</p><p>&emsp;Node开发者们也可以在Node8及以上的版本上体验到async的好处，近两年将会应用于LTS版本。</p><p>&emsp;如果这篇文章并不能让你理解，这里还有几篇JS的文章like<a href="https://babeljs.io/docs/plugins/transform-async-to-generator/" title="Babel" target="_blank" rel="noopener">Babel</a> 和 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html" title="TypeScipt" target="_blank" rel="noopener">TypeScript</a>，而且在node.js里面还提供了他们自己的跨平台版本供我们学习 <a href="https://github.com/yortus/asyncawait" title="asyncawait" target="_blank" rel="noopener">asyncawait</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>随着Async/Await的出现，javascript语言在代码的可读性以及使用简单的方面上提升了一个很大的跨度，它可以让异步代码的编程变得像常规的同步函数一样方便, 这对于不管是新手还是js的老司机来说都是一件值得感激的事情。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> Javascript </category>
          
          <category> 英文文档翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Async/Await Js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Javascript 设计模式(一) --- 概念小谈</title>
      <link href="/2018/05/05/Javascript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/"/>
      <url>/2018/05/05/Javascript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80/</url>
      <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;编写易于维护的代码, 其中一个最重要方面是能够找到代码中重复出现的主题并优化他们, 这也是设计模式有价值的地方, 设计模式不仅适用于原生javascript(既标准javascript代码), 也适用于jQuery库和Dojo等抽象库, 以下内容就是对这本设计模式做的一个读书笔记.</p></blockquote><h2 id="什么是模式"><a href="#什么是模式" class="headerlink" title="什么是模式?"></a>什么是模式?</h2><p>&emsp;&emsp;模式是一种可复用的解决方案, 可用于解决软件设计中遇到的常见问题, 如在我们编写的Javascript应用程序的实例中, 另一种模式的方式是将解决问题的方法制作成模板, 并且这些模板可应用于多种不同的情况.</p><h2 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h2><ul><li>在全局上下文中定义大量的变量污染全局命名空间</li><li>向 setTimeout 和 setInterval 传递字符串, 而不是函数, 这会触发eval() 的内部使用</li><li>修改 Object 类的原型 (<strong>这是一个特别不良的反模式</strong>)</li><li>以内联形式使用 Javascript , 它是不可改变的</li><li>在使用 <code>document.creatElement</code> 等原生 DOM 方法更合适的情况下使用 document.write</li></ul><h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><h3 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h3><ul><li>创建型设计模式专注于处理对象创建机制, 以适合给定情况的方式来创建对象</li><li>属于这个类型的有: Constructor(构造器) Factory(工厂) Abstract(抽象) Prototype(原型) Singleton(单例) 和 Builder(生成器)</li></ul><h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><ul><li>与对象组合有关, 通常用于找出在不同对象之间建立关系的简单方法</li><li>属于这个类型的有: Decorator(装饰器) Facade(外观) Flyweight(享元) Adapter(适配器) 和 Proxy(代理)</li></ul><h3 id="行为设计模式"><a href="#行为设计模式" class="headerlink" title="行为设计模式"></a>行为设计模式</h3><ul><li>专注于改善或简化系统中不同对象之间的通信 </li><li>属于这个类型的有: Iterator(迭代器) Mediator(中介者) Observer(观察者) 和 Visitor(访问者)</li></ul><h2 id="Javascript设计模式"><a href="#Javascript设计模式" class="headerlink" title="Javascript设计模式"></a>Javascript设计模式</h2><h3 id="Constructor-构造器-模式"><a href="#Constructor-构造器-模式" class="headerlink" title="Constructor (构造器) 模式"></a>Constructor (构造器) 模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Constructor是一种在内存已分配给该对象的情况下, 用于初始化新创建对象的特殊方法, 我们最感兴趣的是 <code>Object</code> 构造器 (用于创建特定类型的对象)</p><h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><ul><li><p>创建对象的两种常用方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 字面量的方法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">Obj</span> = &#123;&#125;</span><br><span class="line"><span class="comment">// 2. object构造器的简洁记法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">Obj</span> = <span class="keyword">new</span> <span class="type">Object</span>()</span><br></pre></td></tr></table></figure></li><li><p>给对象赋值的四种方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. '点' 的语法</span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>.someKey = <span class="string">'Hello world'</span>; <span class="comment">// 设置属性</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="keyword">new</span><span class="type">Obj</span>.someKey; <span class="comment">// 获取属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 中括号语法 </span></span><br><span class="line"><span class="keyword">new</span><span class="type">Obj</span>[<span class="string">'someKey'</span>] = <span class="string">'Hello world'</span>; <span class="comment">// 设置属性</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="keyword">new</span><span class="type">Obj</span>[<span class="string">'someKey'</span>]; <span class="comment">// 获取属性</span></span><br><span class="line"></span><br><span class="line">**下面两个只适用ECMAScript <span class="number">5</span>**</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Object.defineProperty</span></span><br><span class="line"><span class="keyword">var</span> defineProp = <span class="function"><span class="keyword">function</span></span>(obj, key, value) &#123;</span><br><span class="line">  config.value = value;</span><br><span class="line">  Object.defineProperty(obj, key, config)</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 先创建一个空的person对象</span></span><br><span class="line"> <span class="keyword">var</span> person = Object.create(<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">// 然后设置各种属性</span></span><br><span class="line"> defineProp.(person, <span class="string">'car'</span>,<span class="string">'Delorean);</span></span><br><span class="line"><span class="string"> defineProp.(person, '</span>dateOfBirth<span class="string">','</span><span class="number">1981</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Object.defineProperties </span></span><br><span class="line">Object.defineProperties(<span class="keyword">new</span><span class="type">Obj</span>, &#123;</span><br><span class="line">  <span class="string">'someKey'</span>: <span class="type"></span>&#123;</span><br><span class="line">    value: <span class="type"></span>'hello world<span class="string">',</span></span><br><span class="line"><span class="string">    writable: true </span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  '</span>authorKey<span class="string">': &#123;</span></span><br><span class="line"><span class="string">    value: '</span>Carol<span class="string">',</span></span><br><span class="line"><span class="string">    writable: false </span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//可以用1和2中获取属性的方式获取3和4方式中的属性**</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="基本-Constructor-构造器"><a href="#基本-Constructor-构造器" class="headerlink" title="基本 Constructor (构造器)"></a>基本 Constructor (构造器)</h4><p>通过在构造器前面加<code>new</code>关键字, 告诉Javascript像使用构造器一样实例化一个新对象, 并且对象成员由该函数定义, 在构造器内, 关键字<code>this</code>引用新创建的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">model, year , miles</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  <span class="keyword">this</span>.year = year;</span><br><span class="line">  <span class="keyword">this</span>.miles = miles;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model + <span class="string">' has done '</span> + <span class="keyword">this</span>.miles + miles;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法, 使用new关键字创建car的实例</span></span><br><span class="line"><span class="keyword">var</span> civic = <span class="keyword">new</span> Car(<span class="string">'BMW'</span>, <span class="number">2009</span>, <span class="number">20000</span>);</span><br><span class="line"><span class="keyword">var</span> mondeo = <span class="keyword">new</span> Car(<span class="string">'Ford Mondeo'</span>, <span class="number">2009</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个实例都可以使用toString方法</span></span><br><span class="line"><span class="built_in">console</span>.log(civic.toString())</span><br></pre></td></tr></table></figure><blockquote><p>这里有两个问题: 一个是继承比较困难, 第二个是 toString方法是为每一个实例分别重新定义的, 这不太理想</p></blockquote><h4 id="带原型的-Constructor-构造器"><a href="#带原型的-Constructor-构造器" class="headerlink" title="带原型的 Constructor (构造器)"></a>带原型的 Constructor (构造器)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造一下上面一个构造函数的写法</span></span><br><span class="line">Car.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.model + <span class="string">' has done '</span> + <span class="keyword">this</span>.miles + miles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**__这样的话, toString()的单一实例就能在所有的Car实例之间共享__**</span><br></pre></td></tr></table></figure><p><em>我们这里可以使用Object.prototype.newMethod, 而不使用Object.prototype是为了避免重新定义prototype对象</em></p><h3 id="Module-模块-模式"><a href="#Module-模块-模式" class="headerlink" title="Module (模块) 模式"></a>Module (模块) 模式</h3><p>在Javascript中, 有几种实现模块的方法 (<font color="blue">Module模式在某种程度上是基于对象字面量</font>)</p><ul><li>对象字面量表示法</li><li>Module 模块</li><li>AMD 模块</li><li>CommonJS 模块</li><li>ECMAScript Harmony 模块</li></ul><h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><p>对象字面量不需要使用 new 关键字进行实例化, 但不能用在一个语句的开头, 对象字面量可以包含属性和方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">  myProperty: <span class="string">'someKey'</span>,</span><br><span class="line">  myConfig : &#123;</span><br><span class="line">    useCacheing: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  myMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">myModule.myMethod()</span><br></pre></td></tr></table></figure></p><h4 id="Module-模块-模式-1"><a href="#Module-模块-模式-1" class="headerlink" title="Module (模块) 模式"></a>Module (模块) 模式</h4><p>模块模式使用闭包封装’私有’状态和组织, 它提供了一直包装混合公有/私有方法和变量的方式, 防止其泄露至全局变量, 这为我们提供了一个屏蔽处理底层事件逻辑的整洁解决方案, 该模式除了返回一个对象而不是一个函数之外, 非常类似于一个立即调用的函数表达式</p><p> 我们可以使用这种模式实现简单的购物车<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basketModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有属性和方法</span></span><br><span class="line">  <span class="keyword">var</span> basket = [];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dosomethingPrivate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个暴露出的公有对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 添加item到购物车</span></span><br><span class="line">    addItem: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      basket.push(value);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取购物车里的item个数</span></span><br><span class="line">    getItemCount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> basket.length;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有函数的公有化别名</span></span><br><span class="line">    doSomething: dosomethingPrivate,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...其他函数. 操作等</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用: basketModule返回一个拥有公有API的对象</span></span><br><span class="line">baskModule.addItem(&#123;</span><br><span class="line">  item: <span class="string">'bread'</span>,</span><br><span class="line">  price: <span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(baskModule.getItemCount) <span class="comment">/// 输出1</span></span><br></pre></td></tr></table></figure></p><p> <em>注意: 这里的basket并没有暴露出来, 只存在于basketModule的闭包作用域里面, 外界无法使用</em></p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点: 可以使脚本语法更加一致, 很容易指出哪些函数和变量可以被公开访问, 提高可读性</li><li>缺点: 如果一个私有函数引用一个公有函数, 在需要补丁时, 公有函数是不能被覆盖的. 引用私有变量的公有对象成员也遵守无补丁规则</li></ul><h3 id="Singleton-单例"><a href="#Singleton-单例" class="headerlink" title="Singleton (单例)"></a>Singleton (单例)</h3><ul><li>定义: 单例模式就是在实例不存在的情况下, 可以通过一个方法创建一个类来实现创建类的新实例, 如果实例已经存在, 他会简单返回该对象的引用</li><li>在Javascript中, Singleton充当共享资源命名空间, 从全局命名空间中隔离出代码实现, 从而为函数提供单一访问点</li><li>适用性:<ul><li>当类只能有一个实例而且用户可以从一个众所周知的访问点访问它时</li><li>该唯一的实例是通过子类化可扩展的, 并且客户应该无需更改代码就能使用一个扩展的实例时</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Singletontester = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Singleton</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">      option = option || &#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置一些属性</span></span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">'Singletontester'</span>;</span><br><span class="line">      <span class="keyword">this</span>.pointX = option.pointX || <span class="number">6</span>;</span><br><span class="line">      <span class="keyword">this</span>.pointY = option.pointY || <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例持有者</span></span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量和方法的模拟</span></span><br><span class="line">    <span class="keyword">var</span> _static = &#123;</span><br><span class="line">      name: <span class="string">'Carol'</span>,</span><br><span class="line">      <span class="comment">// 获取实例的方法, 返回Singleton对象的singleton实例</span></span><br><span class="line">      getInstance: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance === <span class="literal">undefined</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton(options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _static;</span><br><span class="line"> &#125;)()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用</span></span><br><span class="line"> <span class="keyword">var</span> test = Singletontester.getInstance(&#123;</span><br><span class="line">   pointX: <span class="number">5</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(test.pointX) <span class="comment">// 输出</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Web前端 </category>
          
          <category> Javascript </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 Js </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
